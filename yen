
#include <iostream>
using namespace std;

int countOfNodes;
int K;

void addNodToWay(int** ways, int checkedNode, int lastNode) { //Добавляет вершину в конец маршрута
    for (int i = 0; i < countOfNodes; i++) {
        if (ways[lastNode][i] == -1) {
            ways[lastNode][i] = lastNode;
            return;
        }
    }
}

void copyNodsToWay(int** ways, int from, int to) {//коппирует путь из вершины from в вершину to
    for (int i = 0; i < countOfNodes; i++)
        ways[to][i] = ways[from][i];
}

void copyNods(int** A, int rowA, int** B, int rowB) { //коппирует строку(путь) из одной матрицы в другую
    for (int i = 0; i < countOfNodes; i++) {
        A[rowA][i] = B[rowB][i];
    }
}


void Dijkstra(int** adjacencyMatrix, int source, int sink, int** ways) {
    int* distant = new int[countOfNodes]; //кратчайшие расстояния от исходной точки до всех остальных
    bool* checked = new bool[countOfNodes]; //окрашеные узлы
    int index;
    for (int i = 0; i < countOfNodes; i++) {
        distant[i] = 1000;
        checked[i] = false;
    }

    distant[source] = 0;
    ways[source][0] = source;


    //    for (int count = 0; count < countOfNodes - 1; count++) //рассмотрим в худшем случае все вершины кроме текущей
    for (int count = 0; count < countOfNodes; count++)
    {
        // находим узел с минимальным значением расстояния на текущей итерации
        int min = 1000;
        for (int i = 0; i < countOfNodes; i++)
            if (!checked[i] && distant[i] <= min)
            {
                min = distant[i];
                index = i;
            }
        checked[index] = true;


        for (int i = 0; i < countOfNodes; i++) //анализируем смежные вершины, находим кратчайшее расстояние до них
            if ((index != i) && (distant[index] + adjacencyMatrix[index][i] < distant[i])) {


                distant[i] = distant[index] + adjacencyMatrix[index][i];

                //путь до i вершины есть путь до помеченной вершины + сама вершина
            //    ways[i] = ways[index];
                copyNodsToWay(ways, index, i);
                addNodToWay(ways, index, i);
            }
    }


}

int size(int** A, int row) { //длинна строки (кол-во вершин в пути)
    for (int i = 0; i < countOfNodes; i++) {
        if (A[row][i] == -1)
            return i;
    }
    return countOfNodes;
}

int countPath(int** A, int countRows) { //считает кол-во путей

    int k = 0;
    for (int i = 0; i < countRows; i++) {

        if (A[i][0] == -2) //сюда может попасть массив B
            continue;

        if (A[i][0] == -1)
            return k;
        k++;
    }
    return countOfNodes;
}

bool equalsPaths(int* rootPath, int* p, int endNode) {
    for (int i = 0; i < endNode; i++) {
        if (rootPath[i] != p[i])
            return false;
    }
    return true;
}

void revomeEdge(int* p, int indNode1, int indNode2, int** graph) { //удаляет связь между вершинами node1 и node2

    int node1 = p[indNode1];
    int node2 = p[indNode2];

    if ((node1 == -1) or (node2 == -1))
        return;
    graph[node1][node2] = 1000;
    graph[node2][node1] = 1000;
}
void removeRootPathNode(int** graph, int* rootPath, int spurNode) { //чистит пусть от развлетвляющейся вершины во временном графе
    int tekNode;

    for (int i = 0; i < countOfNodes; i++) {
        if (rootPath[i] == spurNode)
            return;
        tekNode = rootPath[i];
        for (int j = 0; j < countOfNodes; j++) {
            graph[tekNode][j] = 1000;
            graph[j][tekNode] = 1000;
        }
    }
}

void sumOfSet(int* totalPath, int* rootPath, int* spurPath) { //складываем пути
    int k = 0;
    for (int i = 0; i < countOfNodes; i++) {
        if (rootPath[i] == -1)
            break;
        totalPath[i] = rootPath[i];
        k++;
     //   cout << totalPath[i];
    }
  //  cout << "k = " << k << "\n";
    for (int i = 1; i < countOfNodes; i++) {
        if (k == countOfNodes)
            break;
        totalPath[k] = spurPath[i];
   //     cout << totalPath[k];
        k++;
    }

}

bool pathInPaths(int* totalPath, int** B) {

    for (int i = 0; i < 10000; i++) {
        if (B[i][0] == -1)
            return false;

        if (equalsPaths(totalPath, B[i], countOfNodes))
            return true;
    }
    return false;

}


void  appendPath(int* totalPath, int** B) {
    for (int i = 0; i < 10000; i++)
        if ((B[i][0] == -1) or (B[i][0] == -2)) { // нашли пустое место
            for (int j = 0; j < countOfNodes; j++) { //добавили
                B[i][j] = totalPath[j];
            }
            break;
        }
}


int findSumOfPath(int* path, int** adjencymatrix) {
    int sum = 0;
    for (int i = 0; i < countOfNodes - 1; i++) {
        if (path[i + 1] == -1)
            return sum;
        sum += adjencymatrix[path[i]][path[i + 1]];
    }
    return sum;
}
int getIndexShortestPath(int** B, int** adjencymatrix) { //ищем самый выгодный путь 
    int min = 10000;
    int tekmin;
    int index = -1;
    for (int i = 0; i < 10000; i++) {
        if (B[i][0] == -1) //просмотрели все пути
            return index;
        if (B[i][0] == -2)
            continue;
        tekmin = findSumOfPath(B[i], adjencymatrix);
    //    cout << "Сумма " << i << " пути равна " << tekmin;
        if (tekmin < min) {
            min = tekmin;
            index = i;
        }

    }
    return index;
}

void  deletePath(int index, int** B) { //удаляет путь с индексом index из массива путей B

    for (int i = 0; i < countOfNodes; i++) {
        B[index][i] = -2;
    }

}



void YenKSP(int** A, int** adjacencyMatrix, int source, int sink, int** ways, int K) {

    int indexOfShortPath;


    Dijkstra(adjacencyMatrix, source, sink, ways); //находим 1 кратчайший путь
    cout << source;
    copyNods(A, 0, ways, sink); //запоминаем его в массив А

    int** graph = new int* [countOfNodes]; //временное состояние матрицы смежности с удаленными ребрами/узлами
    for (int i = 0; i < countOfNodes; i++) {
        graph[i] = new int[countOfNodes];
        for (int j = 0; j < countOfNodes; j++) {
            graph[i][j] = adjacencyMatrix[i][j];
        }
    }


    int spurNode; //узел из которого будем искать новые пути (отвлетвления)
    int* rootPath = new int[countOfNodes]; //путь до узла
    int* p = new int[countOfNodes]; //вспомогательный массив
    int* totalPath = new int[countOfNodes]; //сумма путей до развлетляющегося узла и до конечной вершины
    int* shortestPath = new int[countOfNodes]; //хранит кратчайший путь в массиве потенциальных путей B
    //инициализация
    for (int i = 0; i < countOfNodes; i++) {
        rootPath[i] = -1;
        p[i] = -1;
        totalPath[i] = -1;
        shortestPath[i] = -1;
    }

    int** B = new int* [10000]; //Содержат потенциальные пути
    for (int i = 0; i < 10000; i++) {
        B[i] = new int[countOfNodes];
        for (int j = 0; j < countOfNodes; j++) {
            B[i][j] = -1;
        }
    }

    //далее пройдемся по каждому (k-1)-ому кратчайшему пути, убирая из него ребра находя k-ый кратчайший путь
    for (int k = 1; k < K; k++)
    {
    //    cout << "Находим " << k + 1 << " путь \n";
        for (int i = 0; i < (size(A, k - 1) - 1); i++) { //рассмотрим прошлый путь, попробуем удалять из него i-ое ребро
    //        cout << "Длинна прошлого пути равна " << (size(A, k - 1)) << " Сам путь: ";
    //        for (int i = 0; i < countOfNodes; i++)
    //            cout << A[k - 1][i];
     //       cout << "\n";
            spurNode = A[k - 1][i];
     //       cout << "I = " << i << " Развлетвляющяся вершина " << (spurNode) << "\n";


            for (int i = 0; i < countOfNodes; i++)
                rootPath[i] = -1;

     //       cout << "Путь до развлетвляющейся вершнины (с ней включительно):  ";
            for (int j = 0; j <= i; j++) {//найдем путь до вершины отвлетвления
                rootPath[j] = A[k - 1][j];
     //           cout << rootPath[j];
            }
     //       cout << "\n";

            for (int j = 0; j < countPath(A, K); j++) { //теперь просмотрим все имеющийся кратчайшие пути 
      //          cout << "Нашли кратчайший путь (из массива А), у которого путь до развлетвляющейся вершины совпадает. ща выпишем: \n";
                for (int ii = 0; ii < countOfNodes; ii++)
                {
                    p[ii] = A[j][ii];
       //             cout << p[ii];
                }
       //         cout << "\n";


                if (equalsPaths(rootPath, p, i))
                {
       //             cout << "Так, мы тут поняли шо путь из А содержит путь до нашей вершины, окей, теперь удалим связь между " << p[i] << " и " << p[i + 1] << "\n";
                    revomeEdge(p, i, (i + 1), graph); //удаляет связь между развлетвяющейся вершины и следующей
       //             cout << "Ну вроде как удалили, предлагаю взглянуть на новое задание графа: \n\n";
        //            for (int i = 0; i < countOfNodes; i++) {
        //                for (int j = 0; j < countOfNodes; j++) {
        //                    cout << graph[i][j] << " ";
        //                }
        //                cout << "\n\n";
         //           }
                }
            }

        //    cout << "Теперь удалим все вершины до нашей развлетвляющейся.  Напомню путь \n";

        //    for (int i = 0; i < countOfNodes; i++)
        //        cout << rootPath[i];
        //    cout << "\n";
            removeRootPathNode(graph, rootPath, spurNode); //чистит пусть от развлетвляющейся вершины.

        //    cout << "Окей, удалили, теперь смотри новую матрицу \n\n";

        //    for (int i = 0; i < countOfNodes; i++)
        //    {
        //        for (int j = 0; j < countOfNodes; j++)
        //            cout << graph[i][j] << " ";
        //        cout << "\n";
       //     }
        //    cout << "\n";

            for (int i = 0; i < countOfNodes; i++)
                for (int j = 0; j < countOfNodes; j++)
                    ways[i][j] = -1;

            cout << spurNode;
            Dijkstra(graph, spurNode, sink, ways); //находим новый путь от вершины
            cout << "Так, нашли теперь кратчайший путь с текущей комбинацией ребер, от " << spurNode << " до " << sink << "\n";
            for (int i = 0; i < countOfNodes; i++)
                cout << ways[sink][i] << " ";

            cout << "\n";
            if (ways[sink][0] == -1) {
                cout << "а не, вру, не нашли, уходем отсюда \n\n\n";
                continue;
            }


            sumOfSet(totalPath, rootPath, ways[sink]); //объединяем путь до вершины и новый путь от вершины
         //   cout << "Объеденили путь до вершины и от неё \n";
         //   for (int i = 0; i < countOfNodes; i++)
         //       cout << totalPath[i] << " ";
         //   cout << "\n";





            if (not pathInPaths(totalPath, B)) { //помещаем в список потенциальных путей
                appendPath(totalPath, B);
            }
            cout << "Содержание В \n";
           for (int i = 0; i < 10000; i++) {
                if (B[i][0] == -1)
                    break;
                for (int j = 0; j < countOfNodes; j++) {

                    cout << B[i][j] << " ";
                }
                cout << "\n";
            }

        //    cout << "Ок, теперь восстановим матрицу смежности т.е: \n";
            for (int i = 0; i < countOfNodes; i++) { //восстанавливаем вспомогательную матрицу смежности
                graph[i] = new int[countOfNodes];
                for (int j = 0; j < countOfNodes; j++) {
                    graph[i][j] = adjacencyMatrix[i][j];
        //            cout << graph[i][j] << " ";
                }
        //        cout << "\n";
            }
        }

  //      cout << "\n";
        if (countPath(B, 10000) == 0) {
            cout << "B is empty";
            break;
        }

        cout << "Напомню наш массив потенциальных путей B \n\n";

        for (int i = 0; i < 10000; i++) {
            if (B[i][0] == -1)
                break;
            for (int j = 0; j < countOfNodes; j++) {
                cout << B[i][j] << " ";
            }
            cout << "\n";
        }
        cout << "\n";
        // находим кратчайший путь
        indexOfShortPath = getIndexShortestPath(B, adjacencyMatrix);
        cout << "Найдет кратчайший путь - его индекс" << indexOfShortPath << "\n Содержание А : \n";
        //записываем его в A
        appendPath(B[indexOfShortPath], A);
        for (int i = 0; i < K; i++) {
            if (A[i][0] == -1)
                break;
            for (int j = 0; j < countOfNodes; j++) {
                cout << A[i][j] << " ";
            }
            cout << "\n";
        }
        cout << "\n";

        //удаляем кратчайший путь из нашего  массива потенциальных путей
        deletePath(indexOfShortPath, B);
        for (int i = 0; i < 10000; i++) {
            if (B[i][0] == -1)
                break;
            for (int j = 0; j < countOfNodes; j++) {
                cout << B[i][j] << " ";
            }
            cout << "\n";
        }
        cout << "\n";
    }

}



int main()
{
    setlocale(LC_ALL, "Rus");
    cout << "Алгоритм Йена.\nВведите число вершин.\n";

    cin >> countOfNodes;

    cout << "Введите матрицу смежности нагруженного графа \n";

    int** adjacencyMatrix = new int* [countOfNodes]; //матрица смежности
    for (int i = 0; i < countOfNodes; i++)
        adjacencyMatrix[i] = new int[countOfNodes];

    int k;
    for (int i = 0; i < countOfNodes; i++)
        for (int j = 0; j < countOfNodes; j++) {
            cin >> k;
            if (k == 0)
                adjacencyMatrix[i][j] = 1000;
            else
                adjacencyMatrix[i][j] = k;
        }

    cout << "Введите номер начальной вершины \n";
    int source;
    cin >> source;

    cout << "Введите номер конечной вершины \n";
    int sink;
    cin >> sink;

    //номер строки - номер вершины до которой ищется кратчайший путь, строка - содержание пути из номеров вершин
    int** ways = new int* [countOfNodes];
    for (int i = 0; i < countOfNodes; i++)
        ways[i] = new int[countOfNodes];

    for (int i = 0; i < countOfNodes; i++)
        for (int j = 0; j < countOfNodes; j++)
            ways[i][j] = -1;


    cout << "Введите количество кратчайших путей \n";
    cin >> K;


    int** A = new int* [K];
    for (int i = 0; i < K; i++)
        A[i] = new int[countOfNodes];
    for (int i = 0; i < K; i++)
        for (int j = 0; j < countOfNodes; j++)
            A[i][j] = -1;

    ////////////////////

    YenKSP(A, adjacencyMatrix, source, sink, ways, K);

    cout << "Вывод кратчайших путей \n";
    for (int i = 0; i < K; i++) {
        cout << i << " ||";
        for (int j = 0; j < countOfNodes; j++) {
            if (A[i][j] != -1)
                cout << A[i][j]+1;
        }
        cout << " " << findSumOfPath(A[i], adjacencyMatrix) << "\n";
    }
    /// //////////////

    cin.get();
    return 0;
}
